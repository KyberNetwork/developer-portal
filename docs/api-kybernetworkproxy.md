---
id: KyberNetworkProxy
title: KyberNetworkProxy
---
# contract KyberNetworkProxy
is [KyberNetworkProxyInterface](api-kybernetworkproxyinterface.md), [SimpleNetworkInterface](https://github.com/KyberNetwork/smart-contracts/blob/master/contracts/SimpleNetworkInterface.sol), [Withdrawable](api-withdrawable.md), Utils2\
imports ERC20Interface, [Withdrawable](api-withdrawable.md), Utils2, [KyberNetworkInterface](api-kybernetworkinterface.md), [KyberNetworkProxyInterface](api-kybernetworkproxyinterface.md), [SimpleNetworkInterface](https://github.com/KyberNetwork/smart-contracts/blob/master/contracts/SimpleNetworkInterface.sol)

*Source*: [KyberNetworkProxy.sol](https://github.com/KyberNetwork/smart-contracts/blob/master/contracts/KyberNetworkProxy.sol)

The KyberNetworkProxy contract's role is to facilitate two main functionalities, which is to return the expected exchange rate, and to execute a trade.
___

## INDEX

<AUTOGENERATED_TABLE_OF_CONTENTS>

## REFERENCE

### Structs

### `TradeOutcome`
| Property          | Type            | Description                              |
| ------------------ |:---------------:|:----------------------------------------:|
| `userDeltaSrcAmount`           | uint | source ERC20 token balance of user                         |
| `userDeltaDestAmount`              | uint           | destination ERC20 token balance of user      |
| `actualRate` | uint | Exchange rate between srcToken and destToken |
<br />

### `UserBalance`
| Property          | Type            | Description                              |
| ------------------ |:---------------:|:----------------------------------------:|
| `srcBalance`           | uint | source ERC20 token balance of user                         |
| `destBalance`              | uint           | destination ERC20 token balance of user      |
<br />

### Events

### `ExecuteTrade`
Event for logging execution of trades.
___
event __ExecuteTrade__(address indexed sender, ERC20 src, ERC20 dest, uint actualSrcAmount, uint actualDestAmount)
| Parameter          | Type            | Description                              |
| ------------------ |:---------------:|:----------------------------------------:|
| `sender`           | address | sender's address                         |
| `src`              | ERC20           | source ERC20 token contract address      |
| `dest`             | ERC20           | destination ERC20 Token contract address |
| `actualSrcAmount`  | uint            | source ERC20 token amount in wei         |
| `actualDestAmount` | uint            | destination ERC20 token amount in wei    |
<br />

### `KyberNetworkSet`
Event for logging of updating the KyberNetwork contract.
___
event __KyberNetworkSet__(address newNetworkContract, address oldNetworkContract)
| Parameter | Type    | Description                                                    |
| ----------|:-------:|:--------------------------------------------------------------:|
| `newNetworkContract`     | address   | new KyberNetwork contract address                            |
| `oldNetworkContract`    | address   | old KyberNetwork contract address                       |
<br />

### Functions

### `KyberNetworkProxy`
Contract constructor. Note that constructor methods are called exactly once during contract instantiation and cannot be called again.
___
function __KyberNetworkProxy__(address \_admin) public
| Parameter  | Type    | Description            |
| ---------- |:-------:|:----------------------:|
| `_admin`   | address | admin's wallet address |
___
Web3 Example:
```js
const fs = require('fs');
const solc = require('solc');
const Web3 = require('web3');

const web3 = new Web3(new Web3.providers.HttpProvider('http://localhost:8545'));
const input = fs.readFileSync('KyberNetworkProxy.sol', 'utf8');
const output = await solc.compile(input, 1);
const bytecode = output.contracts['KyberNetworkProxy'].bytecode;
const abi = JSON.parse(output.contracts['KyberNetworkProxy'].interface);

const KyberNetworkProxy = new web3.eth.Contract(JSON.parse(abi));
const _admin = '<ADMIN ADDRESS>';

const deploy = KyberNetworkProxy.deploy({
  data: `0x${bytecode}`,
  arguments: [
    _admin
  ]
});

broadcastTx(deploy)
```
Code snippet reference: [broadcastTx()](appendix-codes.md#broadcasting-tx)
<br />

### `enabled`
Get the state of the network.
___
function __enabled__ public view returns (bool) \
**Returns:**\
`true` if trades are enabled, `false` otherwise
___
Web3 Example:
```js
let result = await kyberNetworkProxyContract.methods.enabled().call()
```
<br />

### `getExpectedRate`
Get the expected exchange rate.
___
function __getExpectedRate__(ERC20 src, ERC20 dest, uint srcQty) public view returns (uint expectedRate, uint slippageRate)
| Parameter | Type  | Description                              |
| --------- |:-----:|:----------------------------------------:|
| `src`     | ERC20 | source ERC20 token contract address      |
| `dest`    | ERC20 | destination ERC20 token contract address |
| `srcQty`  | uint  | wei amount of source ERC20 token         |
**Returns:**\
The expected exchange rate and slippage rate.<br>

**Notes:**
- Returned values are in 18 decimals regardless of the destination token's decimals
- The Most Significant Bit (MSB) is used for excluding permissionless reserves, since this function lacks a hint parameter for this purpose.

#### Understanding the returned values
To understand what this rate means, divide the obtained value by 10**18. Let us look at an example.
Suppose calling `getExpectedRate(KNC_TOKEN,ZIL_TOKEN,1000000000000000000)` returns the following values:
* `expectedRate: 8364817722526000000`
* `slippageRate: 8113873190850220000`

` 8364817722526000000 / (10**18) = 8.364817722526`
Hence, 1 KNC token can be converted to 8.365 ZIL tokens.

#### Turning on MSB to exclude permissionless reserves
Add `2**255` to the desired `srcQty`. As `2**255` is a really large number, the use of a BigNum library / package is recommended for calculations. Refer to the latter part of the web3 example below.
___
Web3 Example:
```js
const src = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee' // ETH
const dest = '0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359' // DAI
const srcQty = new web3.utils.BN('3000000000000000000000')

let result = await kyberNetworkProxyContract.methods.getExpectedRate(
	src,
	dest
	srcQty
).call()

//Example where MSB is turned on to exclude permissionless reserves
const hint = new web3.utils.BN('57896044618658097711785492504343953926634992332820282019729792003956564819968') // 2^255 (turning on MSB)
const newSrcQty = srcQty.add(hint)
let result = await kyberNetworkProxyContract.methods.getExpectedRate(
	src,
	dest
	newSrcQty
).call()
```
<br />

### `getUserCapInWei`
Get the user's exchange limit based on whether user has been KYC'd or not.
___
function __getUserCapInWei__(address user) public view returns (uint)
| Parameter | Type    | Description    |
| --------- |:-------:|:--------------:|
| `user`    | address | user's address |
**Returns:**\
The user's exchange limit in ETH wei
___
Web3 Example:
```js
let result = await KyberNetworkProxy.methods.getUserCapInWei(USER_ADDRESS).call()
```
<br />

### `getUserCapInTokenWei`
Get the user's exchange limit based on whether user has been KYC'd or not.
___
function __getUserCapInTokenWei__(address user, ERC20 token) public view returns (uint)
| Parameter | Type    | Description    |
| --------- |:-------:|:--------------:|
| `user`    | address | user's address |
| `token`    | ERC20 | token contract address |

**Returns:**\
The user's exchange limit in the specified token wei
___
Web3 Example:
```js
const dest = '0xdd974D5C2e2928deA5F71b9825b8b646686BD200' // KNC
let result = await KyberNetworkProxy.methods.getUserCapInTokenWei(USER_ADDRESS,dest).call()
```
<br />

### `info`
Obtain the information given an id (used by an external UI application).
___
function __info__(bytes32 field) public view returns (uint)
| Parameter | Type    | Description                         |
| --------- |:-------:|:-----------------------------------:|
| `field`   | bytes32 | key in the `info` mapping           |

**Returns:**\
The value information.
___
Web3 Example:
```js
let result = KyberNetworkProxy.methods.info('someField').call()
```
<br />

### `maxGasPrice`
Get the maximum gas price limit.
___
function __maxGasPrice__ public view returns (uint)
**Returns:**\
The maximum gas price limit
___
Web3 Example:
```js
let result = await kyberNetworkProxyContract.methods.maxGasPrice().call()
```
<br />

### `setKyberNetworkContract`
To change KyberNetwork.sol contract address
___
function __setKyberNetworkContract__(KyberNetworkInterface _kyberNetworkContract) public onlyAdmin
| Parameter | Type    | Description                         |
| --------- |:-------:|:-----------------------------------:|
| `_kyberNetworkContract`   | KyberNetworkInterface | `KyberNetwork.sol` contract address |
Modifiers: [onlyAdmin](api-permissiongroups.md#onlyadmin)
___
Web3 Example:
```js
let transactionData = KyberNetworkProxy.methods.setKyberNetworkContract(KYBER_NETWORK_CONTRACT_ADDRESS).encodeABI()

txReceipt = await web3.eth.sendTransaction({
	from: ADMIN_ADDRESS,
	to: KYBER_NETWORK_PROXY_ADDRESS,
	data: transactionData
})
```
<br />

### `swapEtherToToken`
Makes a simple ETH -> ERC20 token trade
___
function __swapEtherToToken__(ERC20 token, uint minConversionRate) public payable returns (uint)
| Parameter           | Type    | Description                                   |
| ------------------- |:-------:|:--------------------------------------------------------------------:|
| `token`               | ERC20   | destination ERC20 token contract address                                  |
| `minConversionRate` | uint    | minimum conversion rate;  trade is canceled if actual rate is lower |
**Returns:**\
Amount of actual destination tokens
___
Web3 Example:
```js
const token = '0xdd974D5C2e2928deA5F71b9825b8b646686BD200'; // KNC
const minConversionRate = new web3.utils.BN('55555');
const ethWeiAmt = web3.utils.toWei(0.3)
let transactionData = KyberNetworkProxy.methods.swapEtherToToken(token,minConversionRate).encodeABI()

txReceipt = await web3.eth.sendTransaction({
	from: USER_WALLET_ADDRESS, //obtained from web3 interface
	to: KYBER_NETWORK_PROXY_ADDRESS,
	data: transactionData
	value: ethWeiAmt
 })
```
<br />

### `swapTokenToEther`
Makes a simple ERC20 token -> ETH trade
___
function __swapTokenToEther__(ERC20 token, uint srcAmount, uint minConversionRate) public returns (uint)
| Parameter           | Type    | Description                                   |
| ------------------- |:-------:|:--------------------------------------------------------------------:|
| `token`               | ERC20   | destination ERC20 token contract address                                  |
| `srcAmount`   | uint    | source ERC20 token amount in its token decimals             |
| `minConversionRate` | uint    | minimum conversion rate;  trade is canceled if actual rate is lower |
**Returns:**\
Amount of actual ETH wei
___
Web3 Example:
```js
const token = '0xdd974D5C2e2928deA5F71b9825b8b646686BD200'; // KNC
const minConversionRate = new web3.utils.BN('55555');
const srcAmount = web3.utils.toWei(0.3)
transactionData = KyberNetworkProxy.methods.swapTokenToEther(token,srcAmount,minConversionRate).encodeABI()

txReceipt = await web3.eth.sendTransaction({
	from: USER_WALLET_ADDRESS, //obtained from web3 interface
	to: KYBER_NETWORK_PROXY_ADDRESS,
	data: transactionData
 })
```
<br />

### `swapTokenToToken`
Makes a simple ERC20 -> ERC20 token trade
___
function __swapTokenToToken__(ERC20 src, uint srcAmount, ERC20 dest, uint minConversionRate) public returns (uint)
| Parameter           | Type    | Description                                   |
| ------------------- |:-------:|:--------------------------------------------------------------------:|
| `src`               | ERC20   | source ERC20 token contract address                                  |
| `srcAmount`   | uint    | source ERC20 token amount in its token decimals             |
| `dest`              | ERC20   | destination ERC20 token contract address                             |
| `minConversionRate` | uint    | minimum conversion rate;  trade is canceled if actual rate is lower |
**Returns:**\
Amount of actual destination tokens
___
Web3 Example:
```js
const src = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'; // ETH
const srcAmount = new web3.utils.BN('3000000000000000000000');
const dest = '0xd26114cd6EE289AccF82350c8d8487fedB8A0C07'; // OMG
const minConversionRate = new web3.utils.BN('55555');
transactionData = KyberNetworkProxy.methods.swapTokenToToken(src,srcAmount,dest,minConversionRate).encodeABI()

txReceipt = await web3.eth.sendTransaction({
	from: USER_WALLET_ADDRESS, //obtained from web3 interface
	to: KYBER_NETWORK_PROXY_ADDRESS,
	data: transactionData
 })
```
<br />

### `trade`
Makes a trade between src and dest token and send dest tokens to destAddress.
___
function __trade__(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId) public payable returns (uint)
| Parameter           | Type    | Description                                   |
| ------------------- |:-------:|:--------------------------------------------------------------------:|
| `src`               | ERC20   | source ERC20 token contract address                                  |
| `srcAmount`   | uint    | source ERC20 token amount in its token decimals             |
| `dest`              | ERC20   | destination ERC20 token contract address                             |
| `destAddress`       | address | recipient address for destination ERC20 token                        |
| `maxDestAmount`     | uint    | limit on the amount of destination tokens                            |
| `minConversionRate` | uint    | minimum conversion rate;  trade is canceled if actual rate is lower |
| `walletId`          | address | wallet address to send part of the fees to                           |
**Returns:**\
Amount of actual destination tokens
#### `srcAmount` | `maxDestAmount`
These amounts should be in the source and destination token decimals respectively. For example, if the user wants to swap from / to 10 POWR, which has 6 decimals, it would be `10 * (10 ** 6) = 10000000`

**Note:**<br>`maxDestAmount` should **not** be `0`. Set it to an arbitarily large amount if you want all source tokens to be converted.

#### `minConversionRate`
This rate is independent of the source and destination token decimals. To calculate this rate, take `yourRate * 10**18`. For example, even though ZIL has 12 token decimals, if we want the minimum conversion rate to be `1 ZIL = 0.00017 ETH`, then `minConversionRate = 0.00017 * (10 ** 18)`.

#### `walletId`
If you are part of our [fee sharing program](guide-feesharing.md), this will be your registered wallet address. Set it as `0` if you are not a participant.

#### Other Notes
* Since ETH is not an ERC20 token, we use `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee` as a proxy address to represent it.
* If `src` is ETH, then you also need to send ether along with your call.
* If `src` is an ERC20 token, then `token.approve(KYBER_NETWORK_PROXY_ADDRESS, amount)` should be made beforehand.
* There is a minimum trading value of 1000 wei tokens. Anything fewer is considered as 0.
___
Web3 Example:
```js
const src = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'; // ETH
const srcAmount = new web3.utils.BN('3000000000000000000000');
const dest = '0xdd974D5C2e2928deA5F71b9825b8b646686BD200'; // KNC
const destAddress = "RECIPIENT_ADDRESS"
const maxDestAmount = new web3.utils.BN(Math.pow(2, 255).toString);
const minConversionRate = new web3.utils.BN('55555');
const walletId = '0x0000000000000000000000000000000000000000';

transactionData = KyberNetworkProxy.methods.trade(
	src,
	srcAmount,
	dest,
	destAddress,
	maxDestAmount,
	minConversionRate,
	walletId
).encodeABI()

txReceipt = await web3.eth.sendTransaction({
	from: USER_WALLET_ADDRESS, //obtained from web3 interface
	to: KYBER_NETWORK_PROXY_ADDRESS,
	data: transactionData
 })
```
<br />

### `tradeWithHint`
Makes a trade between src and dest token and send dest tokens to destAddress, with an additional `hint` parameter for exclusion of permissionless reserves.
___
function __tradeWithHint__(address trader, ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount, uint minConversionRate, address walletId, bytes hint) public nonReentrant payable returns (uint)
| Parameter           | Type    | Description                                   |
| ------------------- |:-------:|:--------------------------------------------------------------------:|
| `trader`      |    address |  trader's address |
| `src`               | ERC20   | source ERC20 token contract address                                  |
| `srcAmount`   | uint    | source ERC20 token amount in its token decimals             |
| `dest`              | ERC20   | destination ERC20 token contract address                             |
| `destAddress`       | address | recipient address for destination ERC20 token                        |
| `maxDestAmount`     | uint    | limit on the amount of destination tokens                            |
| `minConversionRate` | uint    | minimum conversion rate;  trade is canceled if actual rate is lower |
| `walletId`          | address | wallet address to send part of the fees to                           |
| `hint` | bytes | for filtering permissionless reserves |
**Returns:**\
Amount of actual destination tokens

**Notes:**
#### `srcAmount` | `maxDestAmount`
These amounts should be in the source and destination token decimals respectively. For example, if the user wants to swap from / to 10 POWR, which has 6 decimals, it would be `10 * (10 ** 6) = 10000000`

#### `maxDestAmount`
This parameter should never be zero. Set to an arbitarily large amount for all source tokens to be converted.

#### `minConversionRate`
This rate is independent of the source and destination token decimals. To calculate this rate, take `yourRate * 10**18`. For example, even though ZIL has 12 token decimals, if we want the minimum conversion rate to be `1 ZIL = 0.00017 ETH`, then `minConversionRate = 0.00017 * (10 ** 18)`.

#### `walletId`
If you are part of our [fee sharing program](guide-feesharing.md), this will be your registered wallet address. Set to the null address if you are not a participant.

#### `hint`
By default, permissionless reserves are included for selection for the trade. To exclude permissionless reserves, parse `PERM` in the `hint` parameter.

#### Other Notes
* Since ETH is not an ERC20 token, we use `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee` as a proxy address to represent it.
* If `src` is ETH, then you also need to send ether along with your call.
* If `src` is an ERC20 token, then `token.approve(KYBER_NETWORK_PROXY_ADDRESS, amount)` should be made beforehand.
* There is a minimum trading value of 1000 wei tokens. Anything fewer is considered as 0.
___
Web3 Example:
```js
const src = '0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee'; // ETH
const srcAmount = new web3.utils.BN('3000000000000000000000');
const dest = '0xdd974D5C2e2928deA5F71b9825b8b646686BD200'; // KNC
const destAddress = "RECIPIENT_ADDRESS";
const maxDestAmount = new web3.utils.BN(Math.pow(2, 255).toString);
const minConversionRate = new web3.utils.BN('55555');
const walletId = '0x0000000000000000000000000000000000000000';
const hint = ""; //hint = "PERM" to filter permissionless reserves

transactionData = KyberNetworkProxy.methods.tradeWithHint(
	src,
	srcAmount,
	dest,
	destAddress,
	maxDestAmount,
	minConversionRate,
	walletId,
	hint
).encodeABI();

txReceipt = await web3.eth.sendTransaction({
	from: USER_WALLET_ADDRESS, //obtained from web3 interface
	to: KYBER_NETWORK_PROXY_ADDRESS,
	data: transactionData
 });
```
