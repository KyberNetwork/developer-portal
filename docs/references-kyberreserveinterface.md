---
id: References-KyberReserveInterface
title: KyberReserveInterface
---
# interface KyberReserveInterface
imports ERC20Interface

*Source*: [KyberReserveInterface.sol](https://github.com/KyberNetwork/smart-contracts/blob/master/contracts/KyberReserveInterface.sol)
___

## INDEX

<AUTOGENERATED_TABLE_OF_CONTENTS>

## REFERENCE

### Functions

### `getConversionRate`
Gets the conversion rate for a pair of tokens at block number.
___
function __getConversionRate__(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) public view returns (uint)
| Parameter     | Type   | Description                              |
| ------------- |:------:|:----------------------------------------:|
| `src`         | ERC20  | source ERC20 token contract address      |
| `dest`        | ERC20  | destination ERC20 token contract address |
| `srcQty`      | uint   | source ERC20 token in its token decimals        |
| `blockNumber` | uint   | current block height or block number     |
**Returns:**\
Current conversion rate of token pairs at `blockNumber`

**Notes:**
* `blockNumber` is an optional field to be used, and is dependent on reserve type.
* The conversion rate returned should be in precision values, where it is independent of both source and destination token decimals. To understand this better, check out [this example](references-kybernetworkproxy.md#understanding-the-returned-values). The [`calcRateFromQty`](https://github.com/KyberNetwork/smart-contracts/blob/master/contracts/Utils2.sol#L36) function will be useful for implementing this functionality.
* If the trade for the requested `srcQty` to `dest` cannot be executed (Eg. due to insufficient liquidity), a value of `0` should be returned.
<br />

### `trade`
Executes a trade between the reserve and the KyberNetwork contract.
___
function __trade__(ERC20 srcToken, uint srcAmount, ERC20 destToken, address destAddress, uint conversionRate, bool validate) public payable returns (bool)
| Parameter        | Type    | Description                                    |
| ---------------- |:-------:|:----------------------------------------------:|
| `srcToken`       | ERC20   | source ERC20 token contract address             |
| `srcAmount`      | uint    | source ERC20 token amount in its token decimals |
| `destToken`      | ERC20   | destination ERC20 token contract address        |
| `destAddress`    | address | recipient address for destination ERC20 tokens  |
| `conversionRate` | uint    | actual conversion rate between srcToken and destToken  |
| `validate`       | bool | Apply additional validations if `true` |
**Returns:**\
`true` if the trade was successful, otherwise `false` if unsuccessful

**Notes**
* `0xeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee` is used to represent Ether. We refer to this as `ETHER_ADDRESS` subsequently.
* The implementation of this function should consider all security checks to prevent rate manipulation, and to make sure the trade executes as expected for the taker.
* To calculate how much `destToken` is required for the trade given `srcAmount` and `conversionRate`, consider using the [`calcDestAmount`](https://github.com/KyberNetwork/smart-contracts/blob/master/contracts/Utils2.sol#L28) function.
* The `validate` field can be ignored.

#### Function Behaviour
* This function should only be used by the KyberNetwork contract. As such, we recommend having a local variable `kyberNetwork` to store the KyberNetwork contract address, and performing a check: `require(msg.sender == kyberNetwork)`. We recommend having a KyberNetwork setter function so that the KyberNetwork contract address can be updated in the event of a contract upgrade.
* `destAddress` will always be `kyberNetworkContract`. While not required, a check could be performed: `require(destAddress == kyberNetworkContract)`.
* Trades will be ETH <> ERC20 token. In other words, **either `srcToken` or `destToken`, but not both**, will always be `ETHER_ADDRESS`. There is no need to handle token to token trades as that is done by the KyberNetwork contract. A validation check can be performed for this.
* If `srcToken` is `ETHER_ADDRESS`, `require(msg.value == srcAmount)`. Otherwise, call `require(srcToken.transferFrom(msg.sender,address(this),srcAmount))`.
* If `destToken` is `ETHER_ADDRESS`, call `destAddress.transfer(destAmount)`. Otherwise, call `destToken.transfer(destAddress,destAmount)`

#### Code Example
The code below is slightly modified from the `trade` function of the Orderbook Reserve.
```
function trade(
  ERC20 srcToken,
  uint srcAmount,
  ERC20 destToken,
  address destAddress,
  uint conversionRate,
  bool validate
  )
  public
  payable
  returns(bool)
  {
    //only kyberNetwork contract allowed to call this function
    require(msg.sender == kyberNetwork);

    //check only ETH <> ERC20 token trades
    require((srcToken == ETH_TOKEN_ADDRESS) || (dstToken == ETH_TOKEN_ADDRESS));
    require((srcToken == token) || (dstToken == token));

    //other validation checks
    require(srcAmount <= MAX_QTY);

    conversionRate;
    // Not using validate variable that is part of the interface.
    validate;

    //validation checks on srcToken
    if (srcToken == ETH_TOKEN_ADDRESS) {
      require(msg.value == srcAmount);
    } else {
      require(msg.value == 0);
      require(srcToken.transferFrom(msg.sender, this, srcAmount));
    }

    //Update balances in orderbook
    uint totalDstAmount = doTrade(
      srcToken,
      srcAmount,
      dstToken
    );

    //send ETH / token back to destAddress (kyberNetwork contract)
    if (dstToken == ETH_TOKEN_ADDRESS) {
      dstAddress.transfer(totalDstAmount);
    } else {
      require(dstToken.transfer(dstAddress, totalDstAmount));
    }

    //emit event
    OrderbookReserveTrade(srcToken, dstToken, srcAmount, totalDstAmount);

    //as required by KyberReserveInterface
    return true;
  }
```
<br />
